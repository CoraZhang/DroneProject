#!/usr/bin/perl

# #!/opt/tools/tools/perl/5.12.2/bin/perl

##############################################################################
# routeClean.pl
# By Chris Spencer (christopher.b.spencer@ericsson.com), 
#    DURA LMR TDS
#    Ottawa, Ontario, CANADA
# (c) Ericsson Canada Inc.
#
# Synopsis:
# --------
# Optimize the route generated by the routeGen.html page to ensure that all points 
# are at least $Distance metres apart.
#
# Version History:
# ---------------
# v0.10 2016/11/18 Chris Spencer
# - Original version.  Based on portions of fleetsim.pl v0.50 by Chris Spencer
#   and getDistance.pl by Chris Spencer.
##############################################################################
$| = 1;

##############################################################################
# libraries
##############################################################################
use Math::Trig;
use File::Basename;
use File::Copy;
use Text::Wrap;
use Cwd;

##############################################################################
# globals
##############################################################################
my $VERSION = '0.10a';
my($SCRIPT, $PATH, $EXT) = fileparse($0, '.pl');
my $DEBUG = 0; # set by -d command-line option

# Change the following Author values as needed.
my $AuthorName = 'Chris Spencer B.';
my $AuthorEmail = 'christopher.b.spencer@ericsson.com';
my $AuthorDept = 'DURA LMR TDS';
my $AuthorCompany = 'Ericsson Canada Inc.';
my $AuthorLocation = 'Ottawa, ON, Canada';

my @InFiles = ();

my $OUTEXT = '.dat'; # output file extension

# date/time globals
my $runTm = time();
my @MONS = qw(JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC);
my @WEEKDAYS = qw(SUN MON TUE WED THU FRI SAT);
my $MINUTE = 60; # seconds
my $HOUR = 60 * $MINUTE; 
my $DAY = 24 * $HOUR; 
my $WEEK = 7 * $DAY; 
my $MONTH = 30 * $DAY;
my $QUARTER = 91 * $DAY;
my $YEAR = 365 * $DAY;
my $MODTIME = 9; # index of file modtime in stat() output
my $COPYRIGHTYEAR = &getYear();

my $EarthRadius = 6378; # km
my $Distance = 100; # metres

##############################################################################
# main
##############################################################################
$SIG{INT} = \&ctrlC; # Ctrl-C interrupt handler

&stderr("$SCRIPT$EXT v$VERSION");
&stderr('-' x length("$SCRIPT$EXT"));

&parseArgs;
if(@InFiles)
  {
   foreach my $infile (@InFiles)
     { &processRouteFile($infile); }
  }
else
  { &warning("No input files specified."); }

&quit;

##############################################################################
# subroutines
##############################################################################

##############################################################################
sub quit
{
 &displayRunDuration;
 exit(0);
}
##############################################################################
sub ctrlC
{
 &warning("User typed Ctrl-C.  Exiting.");
 &quit;
}

##############################################################################
sub parseArgs
{
 # Process all command-line arguments
 my $arg;

 while(@ARGV)
   {
    $arg = shift(@ARGV);

    if($arg eq '-h' || $arg eq '-?') # help
      {
       &help;
       exit;
      }
    elsif($arg eq '-d') # debug
      { 
       $DEBUG = 1;  # debug mode is enabled
       &debug("Debug mode enabled.");
      }
    elsif($arg eq '-m')
      {
       my $temp = shift(@ARGV);
       if($temp >= 10 && $temp <= 1000)
         { $Distance = $temp; }
       else
         { &warning("-m must be from 10 to 1000 metres."); }
      }
    elsif($arg =~ /[\*\?]/)
      {
       &warning("File wildcards not implemented yet.");
      }
    elsif(-e $arg)
      { push(@InFiles, $arg); }
    else
      { &warning("Unknown argument: $arg"); }
  } # end while argv 
}

##############################################################################
sub help
{
 print STDERR <<EOH;

Optimize the route generated by the routeGen.html page to ensure that all points 
are at least the specified number of metres apart.  Default: $Distance metres.

Syntax: $SCRIPT$EXT {options} 

Options:
-m <m> : Minimum distance between points, in metres. Range: 10-1000m. Default: $Distance
-h : This help.
-d : Debug mode.

By $AuthorName ($AuthorEmail), $AuthorDept
   $AuthorCompany, $AuthorLocation
EOH
 &stderr("(c) ".&getYear());
}

##############################################################################
sub stderr
{
 my($msg) = join(" ", @_);
 print STDERR "$msg\n";
}

##############################################################################
sub error
{
 my($err) = join(" ", @_);
 &stderr("FATAL ERROR: $err");
 exit;
}

##############################################################################
sub warning
{
 my($msg) = join(" ", @_);
 &stderr("Warning: $msg"); 
}

##############################################################################
sub debug
{
 my($msg) = join(" ", @_);
 &stderr("DEBUG: $msg") if $DEBUG;
}

##############################################################################
sub getYear
{
 # Return the 4-digit year for the given epoch-time (tm).
 my($tm) = @_;
 $tm = time() unless $tm;
 my $year = (localtime($tm))[5];
 $year += 1900 if($year < 1900);
 return $year;
}

##############################################################################
sub displayRunDuration
{
 my $duration = time() - $runTm;
 if($duration > 7200) # 2 hours
   { &stderr(sprintf("Run Duration: %0.2f hours", $duration/3600)); }
 elsif($duration > 120) # 2 mins
   { &stderr(sprintf("Run Duration: %0.1f minutes", $duration/60)); }
 else
   { &stderr(sprintf("Run Duration: %d seconds", $duration)); }
}

##############################################################################
sub trim
{
 my($str) = @_;
 $str =~ s/^\s+//;
 $str =~ s/\s+$//;
 return $str;
}

##############################################################################
sub processRouteFile
{
 # Read the route file for the given truck.  Routes files contain series of GPS
 # coordinattes which represent a smoothed path of the trucks route.  
 my($routeFile) = @_;
 my @Route = ();
 my($outfile, $backup, $prev);

 &stderr("Processing route file: $routeFile");

 $outfile = $routeFile;
 $backupFile = $routeFile . ".bak";

 unless(File::Copy::move($routeFile, $backupFile))
   { &error("Failed to rename $routeFile to $backupFile."); }

 if(open(DAT, $backupFile))
   {
    while(<DAT>)
      {
       chomp;
       # &debug($_);
       push(@Route, &trim($_));
      }
    close(DAT);
   }
 else 
   { &warning("Could not read route file: $routeFile"); }

 if(@Route)
   {
    if(open(OUT, ">$outfile"))
      { select OUT; }
    else
      { &warning("Output file $outfile could not be opened for writing."); }

    unshift(@Route, "# Inter-point distance optimized to $Distance metres minimum.");
    unshift(@Route, "# Route optimzied by $SCRIPT$EXT v$VERSION By $AuthorName");
    foreach my $line (@Route)
      {
       if($line =~ /^\s*\-?\d+\.?\d*\s*\,\s*\-?\d+\.?\d*\s*$/) # coordinate pair
         {
          $line =~ s/\s//g;
          if($prev)
            {
             my $dist = &calcDist($prev, $line);
             if($dist < $Distance)
               { next; }
            }
          print "$line\n";
          $prev = $line;
         }
       else
         { print "$line\n"; }
      } # end foreach line

    if(fileno(OUT))
      {
       close(OUT);
       select STDOUT;
       &stderr("Output file is: $outfile");
      }
   }
 else
   { &warning("$routeFile was empty."); }
}

##############################################################################
sub calcDist
{
 # Calculate the distance in metres between two points.
 my($origCoords, $destCoords) = @_;
 
 # calculate distance and direction 
 my $dist = sprintf("%0.2f", 
      Math::Trig::great_circle_distance(&NESW(split(/\,/, $origCoords, 2)), 
        &NESW(split(/\,/, $destCoords, 2)), $EarthRadius) * 1000);

 &debug("$origCoords -> $destCoords = $dist m");
 return $dist;
}

##############################################################################
sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
